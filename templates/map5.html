<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>브이월드 WMTS 배경지도 사용하기 오픈레이어스 3버전 이상</title>
    <script src="https://cdn.rawgit.com/openlayers/openlayers.github.io/master/en/v6.5.0/build/ol.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/6.5.0/turf.min.js"></script>
    <script src="https://code.jquery.com/jquery-2.2.3.min.js"></script>
</head>
 
<body>
<div id="map" style="width: 100%; height: 800px; left: 0px; top: 0px"></div>
 
<script type="text/javascript">

    var Base = new ol.layer.Tile({
        name : "Base",
        source: new ol.source.XYZ({
            url: 'http://api.vworld.kr/req/wmts/1.0.0/F6342F62-1FE6-3AE7-A404-6B9E0583385C/Base/{z}/{y}/{x}.png'
        })
    }); // WMTS API 사용
   
    var olView = new ol.View({
        center: [14149214.380024165, 4494012.047228456],//좌표계 변환
        zoom: 14
    })// 뷰 설정
     
    var vectorSource = new ol.source.Vector();
    var vectorLayer = new ol.layer.Vector({
      source: vectorSource,
      style : new ol.style.Style({
        stroke: new ol.style.Stroke({
                color: 'blue',
                width: 10
            })
        })
    });
    var newLine_vectorSource = new ol.source.Vector();
    var newLine_vectorLayer = new ol.layer.Vector({
      source: newLine_vectorSource,
      style : new ol.style.Style({
        stroke: new ol.style.Stroke({
                color: 'red',
                width: 10
            })
        })
    });
     
    var map = new ol.Map({
        layers: [Base,vectorLayer,newLine_vectorLayer],
        target: 'map',
        view: olView
    });
    var lineFeatures = []; // 개별 라인 객체를 저장할 배열
    $.ajax({
        type: "GET",
        url: "{{ url_for('static', filename='map.geojson') }}",
        dataType: 'json',
        success: function(response){
          var format = new ol.format.GeoJSON();
          var features = format.readFeatures(response, {
            dataProjection: 'EPSG:4326',
            featureProjection: 'EPSG:3857'
          });
    
          vectorSource.addFeatures(features);
        }
    });

    map.on("click", function(evt) {
        var center = evt.coordinate;
        // 현재 화면에 겹치는 피처들을 가져옵니다.
        var featuresInExtent = vectorSource.getFeaturesInExtent(map.getView().calculateExtent(map.getSize()));
        lineFeatures = []; // 개별 라인 객체를 저장할 배열
        // 라인 스타일 지정
        var lineStyle = new ol.style.Style({
            stroke: new ol.style.Stroke({
                color: 'red',
                width: 2
            })
        });

        featuresInExtent.forEach(function(feature) {
            var coordinates = feature.getGeometry().getFlatCoordinates();
            for (var i = 0; i < coordinates.length - 1; i += 2) {
                var lineCoordinates = [coordinates[i], coordinates[i + 1]];
                var lineCoordinates2 = [coordinates[i+2], coordinates[i + 3]];
                var lineGeom = new ol.geom.LineString([lineCoordinates , lineCoordinates2]);
                var lineFeature = new ol.Feature({
                    geometry: lineGeom
                });
                lineFeature.setStyle(lineStyle);  // 스타일 적용
                lineFeatures.push(lineFeature);
            }
        });
        //vectorSource.clear(); // 이전에 추가된 피처들 제거
        newLine_vectorSource.clear();
        newLine_vectorSource.addFeatures(lineFeatures);

        var nearestLine = findNearestLineFeature(center);
        if (nearestLine) {
            var lineCoordinates = nearestLine.getGeometry().getCoordinates();
            var minDistance = Infinity;
            var footPoint = null;
            for (var i = 0; i < lineCoordinates.length - 1; i++) {
                var segmentStart = lineCoordinates[i];
                var segmentEnd = lineCoordinates[i + 1];
                var foot = footOfPerpendicular(center, segmentStart, segmentEnd);
                var dist = distance(center, foot);
                if (dist < minDistance) {
                    minDistance = dist;
                    footPoint = foot;
                }
            }
            if (footPoint) {
                var pointFeature = new ol.Feature(new ol.geom.Point(footPoint));
                var pointStyle = new ol.style.Style({
                    image: new ol.style.Circle({
                        radius: 5,
                        fill: new ol.style.Fill({
                            color: 'white'
                        })
                    })
                });
                pointFeature.setStyle(pointStyle);

                newLine_vectorSource.clear();
                newLine_vectorSource.addFeature(pointFeature);
            }
        }

    });
    
    


    // @@@@@@@@@@@@@@@@@ 함수 정의 시작
    function distance(point1, point2) {
        var dx = point2[0] - point1[0];
        var dy = point2[1] - point1[1];
        return Math.sqrt(dx*dx + dy*dy);
    }
    function footOfPerpendicular(point, segmentStart, segmentEnd) {
        var v = [segmentEnd[0] - segmentStart[0], segmentEnd[1] - segmentStart[1]];
        var w = [point[0] - segmentStart[0], point[1] - segmentStart[1]];
        
        var c1 = w[0]*v[0] + w[1]*v[1];
        
        if (c1 <= 0) return segmentStart;
        
        var c2 = v[0]*v[0] + v[1]*v[1];
        
        if (c2 <= c1) return segmentEnd;
        
        var b = c1 / c2;
        return [segmentStart[0] + b * v[0], segmentStart[1] + b * v[1]];
    }
    function pointToSegmentDistance(point, segmentStart, segmentEnd) {
        var v = [segmentEnd[0] - segmentStart[0], segmentEnd[1] - segmentStart[1]];
        var w = [point[0] - segmentStart[0], point[1] - segmentStart[1]];
        
        var c1 = w[0]*v[0] + w[1]*v[1];
        if (c1 <= 0) return distance(point, segmentStart);
        
        var c2 = v[0]*v[0] + v[1]*v[1];
        if (c2 <= c1) return distance(point, segmentEnd);
        
        var b = c1 / c2;
        var projection = [segmentStart[0] + b * v[0], segmentStart[1] + b * v[1]];
        
        return distance(point, projection);
    }
    
    function pointToLineDistance(point, lineCoordinates) {
        var minDistance = Infinity;
        for (var i = 0; i < lineCoordinates.length - 1; i++) {
            var segmentStart = lineCoordinates[i];
            var segmentEnd = lineCoordinates[i + 1];
            var dist = pointToSegmentDistance(point, segmentStart, segmentEnd);
            if (dist < minDistance) {
                minDistance = dist;
            }
        }
        return minDistance;
    }
    
    function findNearestLineFeature(point) {
        var minDistance = Infinity;
        var nearestLine = null;
        
        for (var i = 0; i < lineFeatures.length; i++) {
            var lineFeature = lineFeatures[i];
            var lineCoordinates = lineFeature.getGeometry().getCoordinates();
            var dist = pointToLineDistance(point, lineCoordinates);
            if (dist < minDistance) {
                minDistance = dist;
                nearestLine = lineFeature;
            }
        }
        return nearestLine;
    }

    // @@@@@@@@@@@@@@@@@ 함수 정의 끝



</script>
</body>
</html>